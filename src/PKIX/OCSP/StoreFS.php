<?php

/**
 * This concrete implementation of the abstract class Store provides a means to access a CA repository that is 
 * based on a collection of JSON files.  It's expected that the files will exist in a folder that is not accessible
 * from the internet and that their names are the hex representation of eac generated certificate.
 * 
 * The contents will be the fields and values that can be found in an OpenSSL CA database.  It is expected that 
 * whatever process generates or revokes a certificate will create a file.
 * 
 * Here's an example of the contents of a file:
 * 
 *	{
 *		"status": "R",
 *		"expiryDate": "230530001544Z",
 *		"revokedDate": "210602000329Z,keyCompromise",
 *		"serialNumber": "449EAB6E0A9008BB0591A94710C8D1D3A9DFB93A",
 *		"filename": "unknown",
 *		"distinguishedName": "...The distinguished name from the certificate..."
 *	}
 *
 * If you already have an OpenSSL CA but don't want to use it, the static function createStoreFromOpenSSLDatabase() 
 * can be used to generate files from the CA database.
 * 
 * Of course this implementation can be changed to support any other file system that might be used. See also StoreCA.
 * 
 * Bill Seddon 2021-06-05
 */

namespace PKIX\OCSP;

use Ocsp\Asn1\Element\Enumerated;
use Ocsp\Asn1\Element\GeneralizedTime;
use Ocsp\Asn1\Element\Sequence;
use Ocsp\Asn1\Element\UTCTime;
use Ocsp\Asn1\Tag;
use PKIX\CRL;
use PKIX\Exception\Exception;

use const Ocsp\ERR_UNAUTHORIZED;

/**
 * File system-based implementation of %OCSP responses storage.
 */
class StoreFS extends Store 
{
	/**
	 * If a CA database created and maintained by OpenSSL exists this will create a store from it
	 *
	 * @param string $storeDir
	 * @return void
	 */
	public static function createStoreFromOpenSSLDatabase( $storeDir, $certificateDatabase )
	{
		$database = StoreCA::getIndexIssuedCertificatesInfo( StoreCA::keys, $certificateDatabase );

		$store = __DIR__ . "/store";
		if ( file_exists( $storeDir ) )
			array_map( 'unlink', array_filter((array) glob( "$storeDir/*") ) );
		else
			mkdir( $storeDir, 0777, true );

		foreach( $database as $serialNumber => $data )
		{
			file_put_contents( "$storeDir/$serialNumber", json_encode( $data ) );
		}
	}

	protected $_basedir;

	/**
	 * Configure the storage.
	 *
	 * @param string[] $params Array containing the configiration
	 * directives:
	 * - basedir - full path do the storage root directory
	 *
	 * @throws \PKIX\Exception\Exception with value ERR_CONFIG_ERROR
	 */
	public function config( $params )
	{
		if ( isset( $params['basedir'] ) )
		{
			$this->setBasedir( $params['basedir'] );
		}
	}

	/**
	 * Set the storage root directory
	 *
	 * @param string $basedir full path to the storage root directory
	 *
	 * @throws \PKIX\Exception\Exception with value ERR_CONFIG_ERROR
	 */
	public function setBasedir($basedir)
	{
		if ( is_dir( $basedir ) )
		{
			$this->_basedir = $basedir;
		}
		else
		{
			throw new Exception( "Directory $basedir does not exists", ERR_CONFIG_ERROR );
		}
	}

	/**
	 * Get the response to be generated for the requested certificate
	 *
	 * @param string[] $cid A list of certificate parameters generated by the requestor
	 * @param Sequence[] $certificates An array of the CAs certificate ids indexed by public key hash
	 * @return string Base 64 encoded DER representation of the response
	 */
	public function getResp( $cid, $certificates )
	{
		// Find the certificate
		if ( ! isset( $certificates[ base64_encode( $cid['issuerKeyHash'] ) ] ) )
		{
			throw new Exception( "Issuer certificate not found", \Ocsp\Ocsp::ERR_UNAUTHORIZED );
		}

		/** 
		 * @var Sequence $certificate
		 * @var string $privateKey
		 */
		list( $requestInfo, $privateKey, $caSequence ) = $certificates[ base64_encode( $cid['issuerKeyHash'] ) ];

		// $info = new CertificateInfo();
		// $requestInfo = $info->extractRequestInfo( $caSequence, $caSequence );
		if ( ! $publicKeyBytes = $requestInfo->getIssuerPublicKeyBytes() ?? null )
		{
			throw new Exception( "Unable to find the public key in the responder certificate", \Ocsp\Ocsp::ERR_UNAUTHORIZED );
		}

		// Access the serial number
		$serialNumber = strtoupper( bin2hex( $cid['serialNumber'] ) );

		$filename = "{$this->_basedir}/$serialNumber";

		if ( ! file_exists( $filename ) )
		{
			throw new Exception( "Response not found", \Ocsp\Ocsp::ERR_UNAUTHORIZED );
		}

		$certInfo = json_decode( file_get_contents( $filename ), true );

		$expiryDate = UTCTime::decodeUTCTime( $certInfo['expiryDate'] );
		if ( time() > $expiryDate->getTimestamp() )
		{
			$certInfo['status'] = 'E';
		}

		$status = 0;
		$revokedInfo = null;
		switch( $certInfo['status'] )
		{
			case 'E': // expired
				throw new \Exception( "Certificate revoked", \Ocsp\Ocsp::ERR_UNAUTHORIZED );
			case 'R': // revoked
				$status = 1;
				list( $date, $reason ) = explode( ',', $certInfo['revokedDate'] );
				// The CRL date is UTC but the RevokeInfo date is GeneralizedTime
				$utcDateTime = UTCTime::decodeUTCTime( $date );

				$revokedInfo = Sequence::create( [
					GeneralizedTime::create( $utcDateTime ),
					Enumerated::create( CRL::getRevokeReasonCodeByName( $reason ) )->setTag( Tag::explicit( 0 ) )
				] );
		}

		return $this->createResponse( $cid, $status, $publicKeyBytes, $privateKey, $caSequence, $revokedInfo );
	}

	/**
	 * Get the path to the response from the CertID $cid
	 *
	 * @param array $cid CertID
	 * @return string the constructed path
	 */
	private function getPath( $cid ) 
	{
		return $this->_basedir . "/" . 
			hash('sha256', 
				implode("/",
					array(
						$cid['hashAlgorithm'],
						$cid['issuerNameHash'],
						$cid['issuerKeyHash'],
						$cid['serialNumber']
					)
				)
			);
	}

		/**
	 * Create a CRL for the CA
	 * @return string
	 */
	public function createCRL()
	{
		// TODO
		return null;
	}

}
