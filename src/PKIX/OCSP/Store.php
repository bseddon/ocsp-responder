<?php
namespace PKIX\OCSP;

use \lyquidity\Asn1\Der\Encoder;
use \lyquidity\Asn1\Element;
use \lyquidity\Asn1\Element\BitString;
use \lyquidity\Asn1\Element\Enumerated;
use \lyquidity\Asn1\Element\GeneralizedTime;
use \lyquidity\Asn1\Element\Integer;
use \lyquidity\Asn1\Element\NullElement;
use \lyquidity\Asn1\Element\ObjectIdentifier;
use \lyquidity\Asn1\Element\OctetString;
use \lyquidity\Asn1\Element\RawConstructed;
use \lyquidity\Asn1\Element\RawPrimitive;
use \lyquidity\Asn1\Element\Sequence;
use \lyquidity\Asn1\Tag;
use PKIX\Exception\Exception;

const ERR_CONFIG_ERROR = 1;
const ERR_NOT_FOUND = 2;

/**
 * Abstract class for OCSPServer storage manipulation
 */
abstract class Store
{
	/**
	 * Constructor.
	 *
	 * @param string[] $params Implementation specific configuration parameters
	 */
	public function __construct( $params )
	{
		$this->config( $params );
	}

	/**
	 * Configure the storage.
	 *
	 * @param string[] $params Implementation specific configuration parameters
	 *
	 * @throws \PKIX\Exception\Exception with code ERR_CONFIG_ERROR
	 */
	abstract public function config( $params );

	/**
	 * Search the storage for a %OCSP response data for a certificate
	 * identified by $cid.
	 *
	 * @param array $cid CertID array (see \PKIX\OCSP\Request::parseCertID() for format description)
	 * @param string[] $cid A list of certificate parameters generated by the requestor
	 *
	 * @return string DER-encoded ASN.1 %OCSP response
	 *
	 * @throws \PKIX\Exception\Exception with code ERR_NOT_FOUND when response not found
	 */
	abstract public function getResp( $cid, $certificates );

		/**
	 * Create a response sequence
	 *
	 * @param string[] $cid
	 * @param int $status
	 * @param string $publicKeyBytes
	 * @param string $privateKey
	 * @param Sequence $caSequence
	 * @param Sequence $revokeInfo
	 * @return string
	 */
	protected function createResponse( $cid, $status, $publicKeyBytes, $privateKey, $caSequence, $revokeInfo = null )
	{
		// Create a response
		// The innermost object is a single response
		$singleResponse = Sequence::create([
			// CertID
			Sequence::create([
				// AlgorithmIdentifier [hashAlgorithm]
				Sequence::create([
					// OBJECT IDENTIFIER [algorithm]
					ObjectIdentifier::create( $cid['hashAlgorithm'] ), // SHA1
				] ),
				// OCTET STRING [issuerNameHash]
				OctetString::create( $cid['issuerNameHash'] ),
				// OCTET STRING [issuerKeyHash]
				OctetString::create( $cid['issuerKeyHash'] ),
				// CertificateSerialNumber [serialNumber]
				Integer::create( Integer::decodeInteger( $cid['serialNumber'] ) ),
			]),
			// Status
			$revokeInfo 
				? RawConstructed::create('der', $status, Element::CLASS_CONTEXTSPECIFIC, $revokeInfo->getElements() )
				: RawPrimitive::create( 'der', $status, Element::CLASS_CONTEXTSPECIFIC, '' ),
			// This update
			GeneralizedTime::create( new \DateTimeImmutable('now') ),
			// next update
			GeneralizedTime::create( (new \DateTimeImmutable('now'))->add( new \DateInterval('P7D') ) )->setTag( Tag::explicit( 0 ) )
		]);

		$inst = new SingleResponse( $singleResponse );

		$responseList = Sequence::create( [
			$singleResponse
		] );

		$responseData = Sequence::create( [
			// Version
			// ResponderID - using KeyHash. The alternative is use the CertID and set explicate tad id 1
			OctetString::create( sha1( $publicKeyBytes, true ) )->setTag( Tag::explicit( 2 ) ),
			// Produced at
			GeneralizedTime::create( new \DateTimeImmutable('now') ),
			// Response list as sequence of SingleResponse
			$responseList
		] );

		$responseBytes = (new Encoder())->encodeElement( $responseData );
		$responseSig = "";
		$signResult = openssl_sign( $responseBytes, $responseSig, $privateKey, \lyquidity\OCSP\Ocsp::OID2Name[ \lyquidity\OCSP\Ocsp::sha256WithRSAEncryption ] );
		if( ! $signResult )
			return false;

		// Useful if there is a need to check signing parameters
		// file_put_contents('c:/responder.txt',
		// 	chunk_split( base64_encode( $responseBytes ) ) . "\n\n" .
		// 	chunk_split( base64_encode( $responseSig ) ) . "\n\n" . 
		// 	\Ocsp\Asn1\OID2Name[ \lyquidity\OCSP\Ocsp::sha256WithRSAEncryption ]
		// );

		$basicOCSPResponse = Sequence::create( [
			$responseData,
			// AlgorithmIdentifier - the algorithm use to create the signature see Section 4.1.1.2 of RFC 5280
			Sequence::create( [
				ObjectIdentifier::create( \lyquidity\OCSP\Ocsp::sha256WithRSAEncryption ),
				NullElement::create() // These are any parameters in this case none
			] ),
			// The signature
			BitString::create( $responseSig, 0 ),
			Sequence::create( [
				// The certificate
				$caSequence
			] )->setTag( Tag::explicit( 0 ) )
		] );

		$ResponseBytes = Sequence::create( [
			ObjectIdentifier::create( \lyquidity\OCSP\Ocsp::id_pkix_ocsp_basic ),
			OctetString::create( (new Encoder())->encodeElement( $basicOCSPResponse ) )
		] );

		$ocspResponse = Sequence::create( [
			Enumerated::create( \lyquidity\OCSP\Ocsp::ERR_SUCCESS ),
			$ResponseBytes->setTag( Tag::explicit( 0 ) )
		] );

		// Absolutely minimal but compliant responses.  Possible enum values are:
		//
		// OCSPResponseStatus ::= ENUMERATED {
		// 	successful          (0),  -- Response has valid confirmations
		// 	malformedRequest    (1),  -- Illegal confirmation request
		// 	internalError       (2),  -- Internal error in issuer
		// 	tryLater            (3),  -- Try again later
		// 							  -- (4) is not used
		// 	sigRequired         (5),  -- Must sign the request
		// 	unauthorized        (6)   -- Request unauthorized
		// }
		//
		// return pack('C*', 48, 3, 10, 1, 1);
		// return Sequence::create( [
		//	Enumerated::create( $status )
		// ] );

		return (new Encoder())->encodeElement( $ocspResponse );
	}

	/**
	 * Create a CRL for the CA
	 * @return string
	 */
	abstract function createCRL();
}

